plot(fig, show_link=False,filename='figs/analise-grafica.html')
display(HTML('figs/analise-grafica.html'))


import numpy as np
import matplotlib.pyplot as plt 

# Parâmetros fixados 
t = 12.0
v = 42.0
m = 70.0
g = 9.81


# Localização
a,b = 5,20
c = np.linspace(a,b,100)
f = g*m/c*(1 - np.exp(-c/m*t)) - v # f(c) = 0

plt.plot(c,f,'g-',c,c*0,'r--');
plt.xlabel('c')
plt.ylabel('f(c)')
plt.title('Variação do coeficiente de arrasto')
plt.grid(True)


# Refinamento
a,b = 10,20
c = np.linspace(a,b,100)
f = g*m/c*(1 - np.exp(-c/m*t)) - v

plt.plot(c,f,'g-')
plt.plot(c,0*c,'r--')
plt.grid()


# Refinamento
a,b = 14,16
c = np.linspace(a,b,100)
f = g*m/c*(1 - np.exp(-c/m*t)) - v

plt.plot(c,f,'g-')
plt.plot(c,0*c,'r--')
plt.grid()


# Refinamento
a,b = 14.75,15.5
c = np.linspace(a,b,100)
f = g*m/c*(1 - np.exp(-c/m*t)) - v

plt.plot(c,f,'g-')
plt.plot(c,0*c,'r--')
plt.grid()


# Refinamento
a,b = 15.12,15.14
c = np.linspace(a,b,100)
f = g*m/c*(1 - np.exp(-c/m*t)) - v

plt.plot(c,f,'g-')
plt.plot(c,0*c,'r--')
plt.grid()


import numpy as np, matplotlib.pyplot as plt

class Parachute:
    '''Cria objetos para realizar simulações com o modelo 1D de velocidade terminal
       com base em opções do usuário.
    '''
    
    # Variáveis de classe
    base_param = None
    unit = None
    
    # Construtor
    def __init__(self, lim_inf: float, lim_sup: float, num: int, **kwargs):
        self.dict = kwargs
        self.a = lim_inf
        self.b = lim_sup
        self.num = num        
            
    # Função definidora do modelo matemático 
    def f(self):
                
        params = self.dict.keys()        
        
        # Variável: gravidade
        if 'g' not in params:            
            self.dict['g'] = np.linspace(self.a, self.b, self.num, dtype=np.float32)
            x = self.dict['g']
            self.base_param = 'g'
            self.unit = '$m/s^2$'
        
        # Variável: massa  
        elif 'm' not in params:            
            self.dict['m'] = np.linspace(self.a, self.b, self.num, dtype=np.float32)
            x = self.dict['m']
            self.base_param = 'm'
            self.unit = '$kg$'
            
        # Variável: coef. de arrasto
        elif 'c' not in params:            
            self.dict['c'] = np.linspace(self.a, self.b, self.num, dtype=np.float32)
            x = self.dict['c']
            self.base_param = 'c'
            self.unit = '$kg/s$'
            
        # Variável: tempo
        elif 't' not in params:            
            self.dict['t'] = np.linspace(self.a, self.b, self.num, dtype=np.float32)
            x = self.dict['t']
            self.base_param = 't'
            self.unit = '$s$'
            
        # Variável: velocidade (padrão)
        else:                
            self.dict['v'] = 0.0
            self.dict['t'] = np.linspace(self.a, self.b, self.num, dtype=np.float32)      
            x = self.dict['t']    
            self.base_param = 't'    
            self.unit = '$s$'        

        # Modelo para velocidade terminal
        y = self.dict['g']*self.dict['m']/self.dict['c']*(1 - np.exp( - self.dict['c']/self.dict['m']*self.dict['t'])) - self.dict['v']
        
        return x, y
    
    
    # Função de suporte para plotagem 
    def plot(self, label: str):
        
        x,y = self.f()
            
        h = plt.plot(x,y,label=label)
        plt.xlabel(f'{self.base_param} [{self.unit}]', fontsize=10)
        plt.ylabel(f'y = f({self.base_param})', fontsize=10)              
        plt.grid(True)
        
        return h        


curves = []
for ti in np.linspace(10,30,4,dtype='float32'):
    line, = Parachute(30, 40, num=30, c=10, g=9.85, v=32, t=ti).plot(label=f't={ti:.2f} s')
    curves.append(line)
plt.legend(handles=curves,bbox_to_anchor=(1,1));


curves = []
for gi in np.linspace(9.8,10.4,4,dtype='float32'):
    line, = Parachute(13, 22, num=30, m=70, g=gi, t=60, v=40).plot(label=f'g={gi:.2f} $m/s^2$')
    curves.append(line)
plt.legend(handles=curves,bbox_to_anchor=(1.,1));


# No. de elementos
N = 30

# Função de iteração
x = [1/2]

print(f'x(0) = {x[0]}')
for k in range(1,N):
    phi = x[k-1]**1/2/np.pi - x[k-1]
    x.append(phi)
    print(f'x({k}) = {phi:.4f}')

# Plotagem
plt.figure(figsize=(8,3))
plt.plot(x,'go',label=r'$\dfrac{ (x^{(k)})^{1/2}}{\pi} - x^{(k)}$')
plt.xticks(range(N))
plt.xlabel('$x^{(k)}$',fontsize=12)
plt.ylabel('$\phi_1^{(k)}$',fontsize=12)
plt.grid(axis='both')
plt.legend(loc='upper right');


x(0) = 0.5
x(1) = -0.4204
x(2) = 0.3535
x(3) = -0.2972
x(4) = 0.2499
x(5) = -0.2102
x(6) = 0.1767
x(7) = -0.1486
x(8) = 0.1249
x(9) = -0.1051
x(10) = 0.0883
x(11) = -0.0743
x(12) = 0.0625
x(13) = -0.0525
x(14) = 0.0442
x(15) = -0.0371
x(16) = 0.0312
x(17) = -0.0263
x(18) = 0.0221
x(19) = -0.0186
x(20) = 0.0156
x(21) = -0.0131
x(22) = 0.0110
x(23) = -0.0093
x(24) = 0.0078
x(25) = -0.0066
x(26) = 0.0055
x(27) = -0.0046
x(28) = 0.0039
x(29) = -0.0033


from math import factorial

# No. de elementos
N = 10

# Função de iteração
y = [1/5]
print(f'y(0) = {y[0]}')
for k in range(1,N):
    phi = k/(y[k-1])
    y.append(phi)
    print(f'y({k}) = {phi:.4f}')

# Plotagem
plt.figure(figsize=(8,3))
plt.plot(y,'go',label=r'$\dfrac{k}{x^{(k-1)}}$')
plt.xticks(range(N))
plt.xlabel('$x^{(k)}$',fontsize=12)
plt.ylabel('$\phi_2^{(k)}$',fontsize=12)
plt.grid(axis='both')
plt.legend(loc='center right');


y(0) = 0.2
y(1) = 5.0000
y(2) = 0.4000
y(3) = 7.5000
y(4) = 0.5333
y(5) = 9.3750
y(6) = 0.6400
y(7) = 10.9375
y(8) = 0.7314
y(9) = 12.3047


from numpy import exp, cos

f = lambda x: exp(-x**2)*cos(3*x)
x = np.linspace(0,4,1000)
plt.plot(x,f(x),'g'); plt.grid()


def forca_bruta(f,a,b,n):
    from numpy import linspace
    x = linspace(a,b,n)
    y = f(x)
    raizes = []
    for i in range(n-1):
        if y[i]*y[i+1] < 0:
            raiz = x[i] - (x[i+1] - x[i])/(y[i+1] - y[i])*y[i]
            raizes.append(raiz)
    if len(raizes) == 0:               
        print('Nenhuma raiz foi encontrada')
    return raizes


a,b,n = 0,4,1000
raizes = forca_bruta(f,a,b,n)
print(raizes)


[0.5236017411236913, 1.5708070694852787, 2.6180048381439596, 3.665219264613299]


x2 = np.linspace(2.5,3.8,100)
plt.plot(x2,f(x2),'g',x2,0*f(x2),'r:'); plt.grid()


x3 = np.linspace(3.6,3.7,100)
plt.plot(x3,f(x3),'g',x3,0*f(x3),'r:'); plt.grid()


r = np.array(raizes) # vetoriza a lista
plt.plot(x,0*f(x),'r:',x,f(x),'g-',r,np.zeros(4),'ok',)
plt.xlabel('$x$',fontsize=14)
plt.ylabel('$f(x)$',fontsize=14)        
plt.grid()
plt.title('Raízes de$e^{-x^2}\cos(3x)$');

